<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../styles/form.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700;0,800;1,300;1,400;1,500;1,600;1,700;1,800&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
</head>
<style>
    body {
        font-family: 'Open Sans';
    }
    form > img {
        position: relative;
        left: 42%;
    }
</style>
<body>
    <button id="get-location">Obter Minha Localização</button>
    <div id="res"></div>
</body>
<script>
    const res = document.getElementById('res')
//API KEY => Ao6IBGy_Nf0u4t9E88BYDytyK5mK3kObchF4R0NV5h--iZ6YgwXPMJEckhAEaKlH

// Evento de clique para obter a localização
/*getLocationButton.addEventListener('click', () => {
    if ('geolocation' in navigator) {
        navigator.geolocation.getCurrentPosition(async (position) => {
            const userLat = position.coords.latitude;
            const userLng = position.coords.longitude;

            // Chave de API do Bing Maps (substitua com a sua própria chave)
            const apiKey = 'Ao6IBGy_Nf0u4t9E88BYDytyK5mK3kObchF4R0NV5h--iZ6YgwXPMJEckhAEaKlH';

            // URL da API de geocodificação do Bing Maps
            const geocodingUrl = `https://dev.virtualearth.net/REST/v1/Locations/${userLat},${userLng}?o=json&key=${apiKey}`;

            try {
                // Fazer uma solicitação para a API de geocodificação
                const response = await fetch(geocodingUrl);
                const data = await response.json();

                if (data.resourceSets.length > 0 && data.resourceSets[0].resources.length > 0) {
                    // Extrair o endereço formatado a partir da resposta da API
                    const formattedAddress = data.resourceSets[0].resources[0].address.formattedAddress;

                    // Exibir o endereço no console.log
                    console.log(`Endereço do usuário: ${formattedAddress}`);
                } else {
                    console.error('Nenhum resultado de geocodificação encontrado.');
                }
            } catch (error) {
                console.error('Erro ao obter o endereço do usuário:', error);
            }
        }, (error) => {
            console.error('Erro ao obter a localização do usuário:', error);
        });
    } else {
        console.error('Geolocalização não suportada pelo navegador.');
    }
});
*/






/*fetch('/graficas-cadastradas')
    .then(response => response.json())
    .then(data => {
        const graficasList = document.getElementById('graficas-list');
        console.log(data.graficas)
        const getLocationButton = document.getElementById('get-location');

// Função para calcular a distância entre duas coordenadas usando a fórmula de Haversine
function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Raio da Terra em quilômetros
    const dLat = (lat2 - lat1) * (Math.PI / 180);
    const dLon = (lon2 - lon1) * (Math.PI / 180);
    const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c;
    return distance;
}

// Evento de clique para obter a localização
// Evento de clique para obter a localização
getLocationButton.addEventListener('click', async () => {
    if ('geolocation' in navigator) {
        navigator.geolocation.getCurrentPosition(async (position) => {
            const userLat = position.coords.latitude;
            const userLng = position.coords.longitude;

            // Chave de API do Bing Maps (substitua com a sua própria chave)
            const apiKey = 'Ao6IBGy_Nf0u4t9E88BYDytyK5mK3kObchF4R0NV5h--iZ6YgwXPMJEckhAEaKlH';

            // URL da API de geocodificação do Bing Maps para o usuário
            const userGeocodingUrl = `https://dev.virtualearth.net/REST/v1/Locations/${userLat},${userLng}?o=json&key=${apiKey}`;

            try {
                // Fazer uma solicitação para a API de geocodificação para o usuário
                const userResponse = await fetch(userGeocodingUrl);
                const userData = await userResponse.json();

                if (userData.resourceSets.length > 0 && userData.resourceSets[0].resources.length > 0) {
                    const userAddress = userData.resourceSets[0].resources[0].address.formattedAddress;

                    // Dados das gráficas cadastradas (você já os obteve com o fetch)
                    const graficasData = data.graficas; // Substitua com os seus dados

                    // Converter os endereços das gráficas em coordenadas de latitude e longitude
                    for (const grafica of graficasData.graficas) {
                        const graficaGeocodingUrl = `https://dev.virtualearth.net/REST/v1/Locations/${grafica.endereçoCad}?o=json&key=${apiKey}`;

                        // Fazer uma solicitação para a API de geocodificação para cada gráfica
                        const graficaResponse = await fetch(graficaGeocodingUrl);
                        const graficaData = await graficaResponse.json();

                        if (graficaData.resourceSets.length > 0 && graficaData.resourceSets[0].resources.length > 0) {
                            // Obter as coordenadas de latitude e longitude da gráfica
                            const graficaLat = graficaData.resourceSets[0].resources[0].point.coordinates[0];
                            const graficaLng = graficaData.resourceSets[0].resources[0].point.coordinates[1];

                            // Calcular a distância entre o usuário e a gráfica
                            const distance = haversineDistance(userLat, userLng, graficaLat, graficaLng);

                            // Adicionar a distância à gráfica para fins de classificação
                            grafica.distance = distance;
                        }
                    }

                    // Classificar as gráficas com base na distância
                    graficasData.graficas.sort((a, b) => a.distance - b.distance);

                    if (graficasData.graficas.length > 0) {
                        const gráficaMaisPróxima = graficasData.graficas[0];
                        console.log('Endereço do usuário:', userAddress);
                        console.log('Endereço da gráfica mais próxima:', gráficaMaisPróxima.endereçoCad);
                    }
                } else {
                    console.error('Nenhum resultado de geocodificação encontrado para o usuário.');
                }
            } catch (error) {
                console.error('Erro ao obter dados de geocodificação:', error);
            }
        }, (error) => {
            console.error('Erro ao obter a localização do usuário:', error);
        });
    } else {
        console.error('Geolocalização não suportada pelo navegador.');
    }
});
    })
    .catch(error => console.error('Erro ao buscar gráficas:', error));

    console.log()


  /*  const getLocationButton = document.getElementById('get-location');

// Função para calcular a distância entre duas coordenadas usando a fórmula de Haversine
function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Raio da Terra em quilômetros
    const dLat = (lat2 - lat1) * (Math.PI / 180);
    const dLon = (lon2 - lon1) * (Math.PI / 180);
    const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c;
    return distance;
}

// Evento de clique para obter a localização
// Evento de clique para obter a localização
getLocationButton.addEventListener('click', async () => {
    if ('geolocation' in navigator) {
        navigator.geolocation.getCurrentPosition(async (position) => {
            const userLat = position.coords.latitude;
            const userLng = position.coords.longitude;

            // Chave de API do Bing Maps (substitua com a sua própria chave)
            const apiKey = 'Ao6IBGy_Nf0u4t9E88BYDytyK5mK3kObchF4R0NV5h--iZ6YgwXPMJEckhAEaKlH';

            // URL da API de geocodificação do Bing Maps para o usuário
            const userGeocodingUrl = `https://dev.virtualearth.net/REST/v1/Locations/${userLat},${userLng}?o=json&key=${apiKey}`;

            try {
                // Fazer uma solicitação para a API de geocodificação para o usuário
                const userResponse = await fetch(userGeocodingUrl);
                const userData = await userResponse.json();

                if (userData.resourceSets.length > 0 && userData.resourceSets[0].resources.length > 0) {
                    const userAddress = userData.resourceSets[0].resources[0].address.formattedAddress;

                    // Dados das gráficas cadastradas (você já os obteve com o fetch)
                    const graficasData = data; // Substitua com os seus dados

                    // Converter os endereços das gráficas em coordenadas de latitude e longitude
                    for (const grafica of graficasData.graficas) {
                        const graficaGeocodingUrl = `https://dev.virtualearth.net/REST/v1/Locations/${grafica.endereçoCad}?o=json&key=${apiKey}`;

                        // Fazer uma solicitação para a API de geocodificação para cada gráfica
                        const graficaResponse = await fetch(graficaGeocodingUrl);
                        const graficaData = await graficaResponse.json();

                        if (graficaData.resourceSets.length > 0 && graficaData.resourceSets[0].resources.length > 0) {
                            // Obter as coordenadas de latitude e longitude da gráfica
                            const graficaLat = graficaData.resourceSets[0].resources[0].point.coordinates[0];
                            const graficaLng = graficaData.resourceSets[0].resources[0].point.coordinates[1];

                            // Calcular a distância entre o usuário e a gráfica
                            const distance = haversineDistance(userLat, userLng, graficaLat, graficaLng);

                            // Adicionar a distância à gráfica para fins de classificação
                            grafica.distance = distance;
                        }
                    }

                    // Classificar as gráficas com base na distância
                    graficasData.graficas.sort((a, b) => a.distance - b.distance);

                    if (graficasData.graficas.length > 0) {
                        const gráficaMaisPróxima = graficasData.graficas[0];
                        console.log('Endereço do usuário:', userAddress);
                        console.log('Endereço da gráfica mais próxima:', gráficaMaisPróxima.endereçoCad);
                    }
                } else {
                    console.error('Nenhum resultado de geocodificação encontrado para o usuário.');
                }
            } catch (error) {
                console.error('Erro ao obter dados de geocodificação:', error);
            }
        }, (error) => {
            console.error('Erro ao obter a localização do usuário:', error);
        });
    } else {
        console.error('Geolocalização não suportada pelo navegador.');
    }
});*/

fetch('/graficas-cadastradas')
    .then(response => response.json())
    .then(data => {
        const graficasList = document.getElementById('graficas-list');
        console.log(data.graficas);

        const getLocationButton = document.getElementById('get-location');

        function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Raio da Terra em quilômetros
    const dLat = (lat2 - lat1) * (Math.PI / 180);
    const dLon = (lon2 - lon1) * (Math.PI / 180);
    const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c;
    return distance;
}

        // Evento de clique para obter a localização
        getLocationButton.addEventListener('click', async () => {
            if ('geolocation' in navigator) {
                navigator.geolocation.getCurrentPosition(async (position) => {
                    const userLat = position.coords.latitude;
                    const userLng = position.coords.longitude;

                    // Chave de API do Bing Maps (substitua com a sua própria chave)
                    const apiKey = 'Ao6IBGy_Nf0u4t9E88BYDytyK5mK3kObchF4R0NV5h--iZ6YgwXPMJEckhAEaKlH';

                    // URL da API de geocodificação do Bing Maps para o usuário
                    const userGeocodingUrl = `https://dev.virtualearth.net/REST/v1/Locations/${userLat},${userLng}?o=json&key=${apiKey}`;

                    try {
                        // Fazer uma solicitação para a API de geocodificação para o usuário
                        const userResponse = await fetch(userGeocodingUrl);
                        const userData = await userResponse.json();

                        if (userData.resourceSets.length > 0 && userData.resourceSets[0].resources.length > 0) {
                            const userAddress = userData.resourceSets[0].resources[0].address.formattedAddress;

                            if (data && data.graficas && data.graficas.length > 0) {
                                // Dados das gráficas cadastradas
                                const graficasData = data.graficas;

                                // Converter os endereços das gráficas em coordenadas de latitude e longitude
                                for (const grafica of graficasData) {
                                    const graficaGeocodingUrl = `https://dev.virtualearth.net/REST/v1/Locations/${grafica.endereçoCad}?o=json&key=${apiKey}`;

                                    // Fazer uma solicitação para a API de geocodificação para cada gráfica
                                    const graficaResponse = await fetch(graficaGeocodingUrl);
                                    const graficaData = await graficaResponse.json();

                                    if (graficaData.resourceSets.length > 0 && graficaData.resourceSets[0].resources.length > 0) {
                                        // Obter as coordenadas de latitude e longitude da gráfica
                                        const graficaLat = graficaData.resourceSets[0].resources[0].point.coordinates[0];
                                        const graficaLng = graficaData.resourceSets[0].resources[0].point.coordinates[1];

                                        // Calcular a distância entre o usuário e a gráfica
                                        const distance = haversineDistance(userLat, userLng, graficaLat, graficaLng);

                                        // Adicionar a distância à gráfica para fins de classificação
                                        grafica.distance = distance;
                                    }
                                }

                                // Classificar as gráficas com base na distância
                                graficasData.sort((a, b) => a.distance - b.distance);

                                if (graficasData.length > 0) {
                                    const gráficaMaisPróxima = graficasData[0];
                                    console.log('Endereço do usuário:', userAddress);
                                    console.log('Endereço da gráfica mais próxima:', gráficaMaisPróxima.endereçoCad);
                                    res.innerHTML = `<p>Endereço do Usuário é <strong>${userAddress}</strong> <br> Gráfica mais próxima cadastrada é <strong>${gráficaMaisPróxima.userCad} ${gráficaMaisPróxima.endereçoCad}</strong></p>`
                                }
                            } else {
                                console.error('Nenhum resultado de gráficas encontrado.');
                            }
                        } else {
                            console.error('Nenhum resultado de geocodificação encontrado para o usuário.');
                        }
                    } catch (error) {
                        console.error('Erro ao obter dados de geocodificação:', error);
                    }
                }, (error) => {
                    console.error('Erro ao obter a localização do usuário:', error);
                });
            } else {
                console.error('Geolocalização não suportada pelo navegador.');
            }
        });
    })
    .catch(error => console.error('Erro ao buscar gráficas:', error));

</script>
</html>